# 实验三问题清单

1. 解释中断向量

   - 把中断/异常与相应的处理方法对应起来
   - 每种中断都会对应一个中断向量号，而这个向量号通过**中断描述符表（Interrupt Descriptor Table，IDT）**就与相应的中断处理程序对应起来

   ![](https://i.loli.net/2019/12/08/aXKc6vGJW2OVSTk.png)

2. 解释中断类型码

   - 我们**把每个中断服务程序进行编号，这个号就代表一个中断服务程序，就是中断类型码**。这个中断类型码是计算机用来查找中断向量用的
   - 中断指令的一般格式为 **“INT n”，其中，n被称为“中断类型码”**

3. 解释中断向量表

   > **中断向量表和中断描述符表**
   >   保护方式下，每个中断服务程序在主存中的起始地址由一个中断描述符保存。系统所有的中断描述符形成一个一个表，称为中断描述符表。
   >
   >   实地址方式下，中断向量表直接保存中断服务程序的起始地址（入口地址、首地址）。
   >
   >   实地址的逻辑地址有16位段基地址和16位偏移地址，所以中断服务程序地址含有16位段基地址CS（高字部分）和16位偏移地址IP（低字部分）、**共4个字节**，按照“低对低、高对高”的小端存储方法保存在中断向量表中。
   >
   >   中断向量表位置固定，表内每个项目按中断向量号0依次安排

   - 起始地址：0
   - 每个中断向量包含4 Bytes
   - 低地址两个Byte放偏移
   - 高地址两个Byte放段描述符
   - 最多256个中断向量

   **以下是另一种ppt的解释：**

   - 中断向量表是指中断服务程序入口地址的偏移量与段基值，一个中断向量占据4字节空间。中断向量表是8086系统内存中最低端1K字节空间，它的作用就是按照中断类型号从小到大的顺序存储对应的中断向量，总共存储256个中断向量。
   - 中断向量表在内存单元的最低处，地址空间为00000H----003FFH(0-1024B)
   - 这个地址正好和中断类型码有一种对应的关系：**中断类型码*4(一个中断向量所占的空间) 就等于这个中断向量的首地址**
   - 每一个中断向量所包含的地址以**低位二字节存储偏移量，高位二字节存储段地址**；
   - 中断类型号×4=存放中断向量的首地址；
   - 按照**实模式的寻址方式**找到对应的中断处理的入口；
   - 在全部256个中断中，**前32个（0—31）为硬件系统所预留，后224个可由用户自定义**；

   ![](https://i.loli.net/2019/12/08/vkWch3xitswDByr.png)

4. 实模式下中断程序地址如何得到?

   每一个中断向量所包含的地址以**低位二字节存储偏移量，高位二字节存储段地址**；按照**实模式的寻址方式**找到对应的中断处理的入口，即：

   **中断程序地址：段地址 << 4 + 偏移量**

5. 保护模式下中断程序地址如何得到?

   - **低地址的0和1两个字节是中断代码的偏移量A15～A0； 高地址的6和7两个字节是中断代码的偏移量A31～A16；**
   - **2和3两个字节是段选择符**，段选择符和偏移量用来形成中断服务子程序的入口地址； 

6. 中断向量的地址如何得到?

   中断类型号×4=存放中断向量的首地址

7. 实模式下如何根据中断向量的地址得到中断程序地址?

   每一个中断向量所包含的地址以**低位二字节存储偏移量，高位二字节存储段地址**；按照**实模式的寻址方式**找到对应的中断处理的入口，即：

   **中断程序地址：段地址 << 4 + 偏移量**

8. 解释中断描述符

   - 保护模式下的中断处理与实模式下的中断处理最大区别在于**寻找中断处理代码入口的方式**
   - 在保护模式下，为每一个中断和异常定义了一个**中断描述符**，来说明中断和异常服务程序的入口地址的属性
   - **由中断描述符表取代实地址模式下的中断向量表**
   - 中断描述符除了含有中断处理程序地址信息外，还包括许多属性和类型位
   - 每个中断描述符**占用连续的8个字节**，中断描述符分为三类：**任务门、中断门和自陷门**，CPU对不同的门有不同的处理方式

   - **低地址的0和1两个字节是中断代码的偏移量A15～A0； 高地址的6和7两个字节是中断代码的偏移量A31～A16；**
   - **2和3两个字节是段选择符**，段选择符和偏移量用来形成中断服务子程序的入口地址； 
   - **4和5两个字节称为访问权限字节**，它标识该中断描述符是否有效、服务程序的特权级和描述符的类型等信息； 	
     I. P（present）：表示中断描述符的有效性； 
     II. DPL（descriptor privilege level）； 
     III. TYPE：指示中断描述符的不同类型

   ![](https://i.loli.net/2019/12/08/XC2I4UFqvcMQgVP.png)

9. 保护模式下中断描述符表如何得到?

   通过IDTR寄存器中包含的32位基地址找到IDT在存储器中的起始地址，然后根据IDTR寄存器中的16位段限（即IDT占用的存储空间）来找到IDT

10. 保护模式下中断门如何得到?

    保护模式下的中断过程则较为复杂，它要借助中断门描述符来获取中断子程序这个目标 段的描述符，也就是说必须经过两次查表才能获得中断服务子程序的入口地址 

    - 装载中断描述符表寄存器

      **CPU切换到保护模式之前**，运行于实模式下的初始化程序必须使用LIDT指令装载中断描述符表IDT，**将IDT基地址与段界值装入IDTR**。如果不完成这一步操作，系统就会100%崩溃。在**返回实模式或系统复位时，IDTR中自动装入000000H的基地址值与03FFH的段界值**。可见实模式的中断向量表是固定在存储器的最底部，而保护模式下的IDT则是可以改变的。 

    - 查中断描述符表

      以IDTR指定的中断描述符表的基地址为起始地址，用**调用号N×8算出偏移量**，即为N号中断门描述符的首地址，由此处取出**中断门**的8个字节

    - 查全局或局部描述符表

      根据**中断门中的选择子（段选择符）和偏移量**得到中断处理程序入口

    ![](https://i.loli.net/2019/12/08/d6c38IAGX4TVHYK.png)

11. 保护模式下如何根据中断门得到中断处理程序地址?

    （参考第10条）

12. 中断的分类，举例不同类型的中断?

    从中断源的角度分类

    - 由**计算机硬件异常或故障引起的中断**，也称为内部异常中断。
    - 由**程序中执行了中断指令引起的中断，也称为软中断**。由程序员通过INT或INT3指令触发，通常当做trap处理，用处：实现系统调用。
    - **外部设备（如输入输出设备）请求引起的中断**，也称为外部中断或I/O中断。

    主要有两类：

    - 由CPU以外的事件引起的中断 —— **中断（外部中断）**

      如I/O中断、时钟中断、控制台中断等。 

      - 可屏蔽中断

        禁止响应某个中断，**保证在执行一些重要的程序中不响应中断**，以免造成迟缓而引起错误。

      - 不可屏蔽中断

        重新启动、电源故障、内存出错、总线出错等**影响整个系统工作的中断是不能屏蔽的**

    - 来自CPU的内部事件或程序执行中的事件引起的过程 —— **异常**

      如由于CPU本身故障、程序故障和请求系统服务的指令引起的中断等。     

13. 中断与异常的区别?

    （参考第21条）

14. 实模式和保护模式下的中断处理差别

    - 保护模式下的中断处理与实模式下的中断处理最大区别在于**寻找中断处理代码入口的方式**
    - 在保护模式下，为每一个中断和异常定义了一个**中断描述符**，来说明中断和异常服务程序的入口地址的属性
    - **由中断描述符表取代实地址模式下的中断向量表**
    - 中断描述符除了含有中断处理程序地址信息外，还包括许多属性和类型位

15. 如何识别键盘组合键 (如 Shift+a) 是否还有其他解决方案?

16. IDT 是什么，有什么作用?

    - 在80x86系列中为中断服务提供中断/陷阱描述符，这些描述符构成中断描述符表（IDT） 
      引入一个48位的全地址寄存器（即中断描述符表寄存器IDTR）存放IDT的内存地址，因此不再限于底部1K位置 
    - 和GDTR一样，**IDTR包含32位的基地址和16位段限，基地址定义中断描述符表IDT在存储器中的起始点，段限定义中断描述符表所占的字节个数**
    - 理论上IDT表同样可以有8K项，可是因为80x86只支持256个中断，因此IDT实际上最大只能有256项（2K大小）

    ![](https://i.loli.net/2019/12/08/gdmxDtEyFPbiovV.png)

17. IDT 中有几种描述符?

    中断描述符分为三类：任务门、中断门和自陷门

18. 异常的分类?

    - Fault，是一种**可被更正的异常**，而且一旦被更正，程序可以不失连续性地继续执行。**返回地址是产生fault的指令**
    - Trap，一种在**发生trap的指令执行之后立即被报告的异常**，它也允许程序或任务不失连续性地继续执行。返回地址是产生trap的指令之后的那条指令
    - Abort，不总是报告精确异常发生位置的异常，**不允许程序或任务继续执行**，而是**用来报告严重错误的**

19. 用户态和内核态的特权级分别是多少?

    用户态（特权级为3）

    内核态（特权级为0）

20. 中断向量表中，每个中断有几个字节? 里面的结构是什么?

    每个中断向量有4个字节，包含的地址以**低位二字节存储偏移量，高位二字节存储段地址**（小端存储）

21. 中断异常共同点 (至少两点)，不同点 (至少三点)

    - 共同点

      - 都是程序执行过程中的**强制性转移**，转移到相应的处理程序
      - 都是软件或者硬件发生了某种情形而**通知处理器的行为**

    - 区别

      - 中断，是CPU所具备的功能，通常因为“硬件”而随机发生；

        异常，是“软件”运行过程中的一种开发过程中没有考虑到的程序错误

      - 中断是CPU暂停当前工作，有计划地去处理其他的事情。中断的发生一般是可以预知的，处理的过程也是事先制定好的。处理中断时程序是正常运行的

        异常是CPU遇到了无法响应的工作，而后进入一种非正常状态。异常的出现表明程序有缺陷

      - 中断是异步的，异常是同步的

        中断是**来自处理器外部的I/O设备的信号的结果，它不是由指令流中某条指令执行引起的**，从这个意义上讲，它是异步的，是来自指令流之外的

        异常是**执行当前指令流中的某条指令的结果，是来自指令流内部的**，从这个意义上讲它们都是同步的

      - 中断或异常的返回点

        良性的如中断和trap，只是在正常的工作流之外执行额外的操作，然后继续干没干完的活。因此处理程序完了后返回到原指令流的下一条指令，继续执行

        恶性的如fault和abort，对于可修复fault，由于是在上一条指令执行过程中发生（是由正在执行的指令引发的）的，在**修复fault之后，会重新执行该指令**；至于**不可修复fault或abort，则不会再返回**

      - 中断是**由于当前程序无关的中断信号触发的**，CPU对中断的响应是被动的，且与CPU模式无关，既可以发生在用户态，又可以发生在核心态；

        异常是**由CPU控制单元产生**的，大部分异常发生在用户态