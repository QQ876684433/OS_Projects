### 2.1 PPT相关内容

1. 什么是实模式，什么是保护模式？

   - 实模式就是用基地址加偏移量就可以直接拿到物理地址的模式
     - 缺点：实模式非常不安全
   - 保护模式就是不能直接拿到物理地址的模式
     - 需要进行地址转换
     - 从80386开始，是现代操作系统的主要模式

2. 什么是选择子？

   （1）选择子共16位，放在段选择寄存器里
   （2）低2位表示请求特权级
   （3）第3位表示选择GDT方式还是LDT方式
   （4）高13位表示**在描述符表中的偏移**（故描述符表的项数最多是2的13次方）

   ![](https://i.loli.net/2019/11/11/V8oWOCkuPTeIc7D.png)

3. 什么是描述符？

   ![](https://i.loli.net/2019/11/11/WQy2geMkTntL64j.png)

   描述符是保护模式下引入的用来描述各种数据段，所有的描述符均为8个字节（0-7），由**第5个字节说明描述符的类型**；类型不同，描述符的结构也有所不同

4. 什么是GDT，什么是LDT?

   - GDT：全局描述符表，是全局唯一的。存放一些公用的描述符、和包含**各进程局部描述符表首地址**的描述符。
   - LDT：局部描述符表，每个进程都可以有一个。存放**本进程内使用的描述符**。

   以上可以理解为二级的表结构

5. 请分别说明GDTR和LDTR的结构。

   - GDTR：48位寄存器，**高32位放置GDT首地址**，**低16位放置GDT限长**（限长决定了可寻址的大小，注意低16位放的不是选择子）
   - LDTR：16位寄存器，放置一个特殊的选择子，用于**查找当前进程的LDT首地址**

6. 请说明GDT直接查找物理地址的具体步骤。

   ![](https://i.loli.net/2019/11/11/4Z3yGjYkcVuq1mI.png)

   - 给出段选择子（放在段选择寄存器里）+偏移量
   - 若选择了GDT方式，则从GDTR获取GDT首地址，用段选择子中的13位做偏移，拿到GDT中的描述符
   - 如果合法且有权限，用描述符中的段首地址加上（1）中的偏移量找到物理地址。寻址结束

7. 请说明通过LDT查找物理地址的具体步骤。

   ![](https://i.loli.net/2019/11/11/wb1s57xSBVpRUDQ.png)

   - 给出段选择子（放在段选择寄存器中）+偏移量
   - 若选择了LDT方式，则从GDTR获取GDT首地址，用LDTR中的偏移量做偏移，拿到GDT中的描述符1
   - 从描述符1中获取LDT首地址，用段选择子中的13位做偏移，拿到LDT中的描述符2
   - 如果合法且有权限，用描述符2中的段首地址加上（1）中的偏移量找到物理地址。寻址结束

8. **根目录区大小一定么？扇区号是多少？为什么？**

   不一定。扇区号=1+9*2=19
   根目录条目不一定。引导分区占一个扇区，每个 fat 占 9 个扇区

9. 数据区第一个簇号是多少？为什么？

   数据区就起始于簇 2。
   在 1.44M 软盘上，FAT 前三个字节的值必须是固定的，分别是 0xF0、0xFF、0xFF，用于表示这是一个应用在 1.44M 软盘上的 FAT12 文件系统。本来序号为 0 和 1 的 FAT 表项应该对应于簇 0 和簇 1，但是由于这两个表项被设置成了固定值，簇 0 和簇 1 就没有存在的意义了。

10. FAT表的作用？

    文件分配表被划分为紧密排列的若干个表项，每个表项都与数据区中的一个簇相对应，而且表项的序号也是与簇号一一对应的

11. 解释静态链接的过程。

    - 静态链接是由链接器**在链接时将库的内容加入到可执行程序中**的做法。
    - 在编译 main.c 的时候，编译器还不知道 printf 函数的地址，所以在编译阶段只是将一个“临时地址”放到目标文件中，在链接阶段，这个“临时地址”将被修正为正确的地址，这个过程叫重定位。所以链接器还要知道该目标文件中哪些符号需要重定位，这些信息是放在了重定位表中。
    - 在链接的时候，我们需要告诉链接器需要链接的目标文件和库文件（默认 gcc 会把标准库作为链接器输入的一部分）。链接器会根据输入的目标文件从库文件中提取需要目标文件。
    - 知道了这些信息后，链接器就可以开始工作了，分为两个步骤：1）合并相似段，把所有需要链接的目标文件的相似段放在可执行文件的对应段中。2）重定位符号使得目标文件能正确调用到其他目标文件提供的函数。

12. 解释动态链接的过程。

    - 所谓动态链接就是在运行的时候再去链接。
    - 从动态库的角度来看，动态库像普通的可执行文件一样，有其代码段和数据段。为了使得动态库在内存中只有一份，需要做到不管动态库装载到什么位置，都不需要修改动态库中代码段的内容，从而实现动态库中代码段的共享。而数据段中的内容需要做到进程间的隔离，因此必须是私有的，也就是每个进程都有一份。因此，动态库的做法是把代码段中变化的部分放到数据段中去，这样代码段中剩下的就是不变的内容，就可以装载到虚拟内存的任何位置。那代码段中变化的内容是什么，主要包括了对外部函数和变量的
      引用。
    - 动态库是把地址相关的内容放到了数据段中来实现地址无关的代码，从而使得动态库能被多个进程共享。
      动态链接生成的可执行文件运行前，系统会首先将动态链接库加载到内存中。当所有的库都被加载进来以后，类似于静态链接，动态链接器从各个动态库中可以知道每个库都提供什么函数（符号表）和哪些函数引用需要重定位（重定位表），然后修正.got 和.got.plt 中的符号到正确的地址，完成之后就可以将控制权交给可执行文件的入口地址，从而开始执行我们编写的代码了。

13. 静态链接相关PPT中为什么使用ld链接⽽不是gcc

    用 gcc 的话有可能去调 C 库，使程序环境变得复杂，所以用 ld

14. linux下可执行文件的虚拟地址空间默认从哪里开始分配。

    

### 2.2 实验相关内容

1. BPB指定字段的含义

2. 如何进⼊子目录并输出（说明方法调用）

3. 如何获得指定文件的内容，即如何获得数据区的内容（比如使用指针等）

4. 如何进行C代码和汇编之间的参数传递和返回值传递

   - 64位模式

     nasm和c语言函数之间的参数传递是通过64位寄存器来进行的

     针对64位整型参数(long类型)，按照参数从左到右的顺序，依次通过寄存器 RDI , RSI , RDX , RCX , R8 , 和 R9 来传递，如果参数个数超过了这么多，那么多余的参数通过栈来传递

     而返回值是通过RAX来传递

   - 32位模式

     参数的传递则是通过栈来实现的；函数返回值存放在eax中

     例如代码：

     ```c
     int add_func(int, int);
     
     int main(){
     	int a = 9, b = 10;
         int c = add_func(a, b);
     	return 0;
     }
     ```

     在进行函数add调用前，会将参数列表依次从右往左入栈：

     ```asm
     push	10
     push	9
     call	add_func
     ```

     在push完10和9后，esp指向栈顶的值恰好是9，当调用`call add_func`后，会将当前函数的返回地址入栈（即`call add_func`执行的下一条指令的地址），此时`esp = esp - 4`（因为32位下一个整数int入栈，栈指针移动是4bytes，并且是往低地址方向移动），此时栈的情况如图：

     ![](https://i.loli.net/2019/11/13/2CZHacdLEQVOflW.png)

     注意，此时ebp指向的依然是main函数的栈底

     接下来，add_func有两种实现方式：

     ```asm
     ; 第一种
     add_func:
     	mov	eax, [esp + 4]
     	mov	ecx, [esp + 8]
     	...
     
     ; 第二种
     add_func:
     	push	ebp
     	mov	ebp, esp
     	mov	eax, [ebp + 8]	; 或者 mov eax, [esp + 8]
     	mov	ecx, [ebp + 12]	; 或者 mov ecx, [esp + 12]
     	...
     ```

     两种方式的唯一区别只在于第二种方式将ebp保存起来，并且将ebp设置为esp的值，这个并不是必要的，因为在add_func没有局部变量的时候，一般esp和ebp值会保持一样，获取参数值的方式是一样的；但是当add_func中有局部变量的时候，esp的值会随着局部变量的入栈而改变，那么使用esp来访问参数值就会变得有些麻烦，所以可以使用ebp来保存当前栈帧的栈底，以便方便地访问参数值（总的来说，在函数内部，ebp一般是不变的，而esp会变化）

     如果使用的是第二种方式，那么栈的情况如下图：

     ![](https://i.loli.net/2019/11/13/7ajwYPIXF6JluUk.jpg)

5. 汇编代码中对I/O的处理方式，说明指定寄存器所存值的含义

   （*才发现，64位模式下Linux的函数调用和系统调用在寄存器的使用上有略微差异，就是函数调用的第4个参数使用rcx，而系统调用使用r10*）

   | %rax | System call |      %rdi       |      %rsi       |     %rdx     | %r10 | %r8  | %r9  |
   | :--: | :---------: | :-------------: | :-------------: | :----------: | :--- | :--: | :--: |
   |  0   |  sys_read   | unsigned int fd |    char *buf    | size_t count |      |      |      |
   |  1   |  sys_write  | unsigned int fd | const char *buf | size_t count |      |      |      |

   - rax：系统调用号，0代表sys_read，1代表sys_write
   - rdi：文件描述符，STDIN_FILENO（标准输入）、STDOUT_FILENO（标准输出） 和 STDERR_FILENO（标准错误） 来代替 0、1、2（系统调用号和文件描述符恰好相同，只是个巧合）
   - rsi：字符缓冲区，sys_read中表示读取的字符流存储在哪里，sys_write中表示要将哪里的字符流进行输出
   - rdx：长度，即要读取或者写出的字符个数